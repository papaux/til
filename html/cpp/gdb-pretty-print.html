

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gdb pretty print &mdash; Geoffrey&#39;s TIL 0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="gdb: navigate in threads" href="gdb-navigate-in-threads.html" />
    <link rel="prev" title="gdb commands" href="gdb-commands.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Geoffrey's TIL
          

          
          </a>

          
            
            
              <div class="version">
                2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../ansible/_.html">Ansible</a></li>
<li class="toctree-l1"><a class="reference internal" href="../archlinux/_.html">ArchLinux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../bash/_.html">Bash</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="_.html">C++</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="gdb-commands.html">gdb commands</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">gdb pretty print</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#with-python">With python</a></li>
<li class="toctree-l3"><a class="reference internal" href="#without-python">Without python</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gdb-navigate-in-threads.html">gdb: navigate in threads</a></li>
<li class="toctree-l2"><a class="reference internal" href="benchmark.html">Benchmark</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../dev-env/_.html">Development environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../docker/_.html">Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../git/_.html">Git</a></li>
<li class="toctree-l1"><a class="reference internal" href="../java/_.html">Java</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kvm/_.html">KVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../linux/_.html">Linux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../markdown/_.html">Markdown</a></li>
<li class="toctree-l1"><a class="reference internal" href="../media/_.html">Media</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mysql/_.html">Mysql</a></li>
<li class="toctree-l1"><a class="reference internal" href="../network/_.html">Network</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nodejs/_.html">NodeJS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../php/_.html">PHP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../postgres/_.html">Postgres</a></li>
<li class="toctree-l1"><a class="reference internal" href="../programming/_.html">Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../python/_.html">Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../sphinx/_.html">Sphinx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../scala/_.html">Scala</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tmux/_.html">tmux</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ubuntu-debian/_.html">Ubuntu / Debian</a></li>
<li class="toctree-l1"><a class="reference internal" href="../vim/_.html">vim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../web/_.html">Web</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wine/_.html">Wine</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Geoffrey's TIL</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="_.html">C++</a> &raquo;</li>
        
      <li>gdb pretty print</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/cpp/gdb-pretty-print.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="gdb-pretty-print">
<h1>gdb pretty print<a class="headerlink" href="#gdb-pretty-print" title="Permalink to this headline">¶</a></h1>
<p>gdb allows to customize the way variable are printed. If you are using
gdb version 7+ and your gdb has been compiled with python support, you
can use the python pretty-printers.</p>
<p>If you have an older gdb or one which doesn’t support python pretty
printers, there is still a possibility to integrate the functions in
your .gdbinit directly.</p>
<div class="section" id="with-python">
<h2>With python<a class="headerlink" href="#with-python" title="Permalink to this headline">¶</a></h2>
<p>You can checkout the scripts at:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">john</span><span class="o">/</span><span class="n">gdb_printers</span><span class="o">/</span>
<span class="n">svn</span> <span class="n">co</span> <span class="n">svn</span><span class="p">:</span><span class="o">//</span><span class="n">gcc</span><span class="o">.</span><span class="n">gnu</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">svn</span><span class="o">/</span><span class="n">gcc</span><span class="o">/</span><span class="n">trunk</span><span class="o">/</span><span class="n">libstdc</span><span class="o">++-</span><span class="n">v3</span><span class="o">/</span><span class="n">python</span>
</pre></div>
</div>
<p>and import them with this .gdbinit:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;/home/john/gdb_printers/python&#39;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">libstdcxx.v6.printers</span> <span class="kn">import</span> <span class="n">register_libstdcxx_printers</span>
<span class="n">register_libstdcxx_printers</span> <span class="p">(</span><span class="kc">None</span><span class="p">)</span>
<span class="n">end</span>
</pre></div>
</div>
</div>
<div class="section" id="without-python">
<h2>Without python<a class="headerlink" href="#without-python" title="Permalink to this headline">¶</a></h2>
<p>Here is a sample .gdbinit with some predefined pretty printers for the
stl: <a class="reference external" href="https://gist.github.com/skyscribe/3978082">https://gist.github.com/skyscribe/3978082</a></p>
<p>For the records, here is a dump of the file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>#
#   STL GDB evaluators/views/utilities - 1.03
#
#   The new GDB commands:
#         are entirely non instrumental
#         do not depend on any &quot;inline&quot;(s) - e.g. size(), [], etc
#       are extremely tolerant to debugger settings
#
#   This file should be &quot;included&quot; in .gdbinit as following:
#   source stl-views.gdb or just paste it into your .gdbinit file
#
#   The following STL containers are currently supported:
#
#       std::vector&lt;T&gt; -- via pvector command
#       std::list&lt;T&gt; -- via plist or plist_member command
#       std::map&lt;T,T&gt; -- via pmap or pmap_member command
#       std::multimap&lt;T,T&gt; -- via pmap or pmap_member command
#       std::set&lt;T&gt; -- via pset command
#       std::multiset&lt;T&gt; -- via pset command
#       std::deque&lt;T&gt; -- via pdequeue command
#       std::stack&lt;T&gt; -- via pstack command
#       std::queue&lt;T&gt; -- via pqueue command
#       std::priority_queue&lt;T&gt; -- via ppqueue command
#       std::bitset&lt;n&gt; -- via pbitset command
#       std::string -- via pstring command
#       std::widestring -- via pwstring command
#
#   The end of this file contains (optional) C++ beautifiers
#   Make sure your debugger supports $argc
#
#   Simple GDB Macros writen by Dan Marinescu (H-PhD) - License GPL
#   Inspired by intial work of Tom Malnar,
#     Tony Novac (PhD) / Cornell / Stanford,
#     Gilad Mishne (PhD) and Many Many Others.
#   Contact: dan_c_marinescu@yahoo.com (Subject: STL)
#
#   Modified to work with g++ 4.3 by Anders Elton
#   Also added _member functions, that instead of printing the entire class in map, prints a member.



#
# std::vector&lt;&gt;
#

define pvector
    if $argc == 0
        help pvector
    else
        set $size = $arg0._M_impl._M_finish - $arg0._M_impl._M_start
        set $capacity = $arg0._M_impl._M_end_of_storage - $arg0._M_impl._M_start
        set $size_max = $size - 1
    end
    if $argc == 1
        set $i = 0
        while $i &lt; $size
            printf &quot;elem[%u]: &quot;, $i
            p *($arg0._M_impl._M_start + $i)
            set $i++
        end
    end
    if $argc == 2
        set $idx = $arg1
        if $idx &lt; 0 || $idx &gt; $size_max
            printf &quot;idx1, idx2 are not in acceptable range: [0..%u].\n&quot;, $size_max
        else
            printf &quot;elem[%u]: &quot;, $idx
            p *($arg0._M_impl._M_start + $idx)
        end
    end
    if $argc == 3
      set $start_idx = $arg1
      set $stop_idx = $arg2
      if $start_idx &gt; $stop_idx
        set $tmp_idx = $start_idx
        set $start_idx = $stop_idx
        set $stop_idx = $tmp_idx
      end
      if $start_idx &lt; 0 || $stop_idx &lt; 0 || $start_idx &gt; $size_max || $stop_idx &gt; $size_max
        printf &quot;idx1, idx2 are not in acceptable range: [0..%u].\n&quot;, $size_max
      else
        set $i = $start_idx
        while $i &lt;= $stop_idx
            printf &quot;elem[%u]: &quot;, $i
            p *($arg0._M_impl._M_start + $i)
            set $i++
        end
      end
    end
    if $argc &gt; 0
        printf &quot;Vector size = %u\n&quot;, $size
        printf &quot;Vector capacity = %u\n&quot;, $capacity
        printf &quot;Element &quot;
        whatis $arg0._M_impl._M_start
    end
end

document pvector
    Prints std::vector&lt;T&gt; information.
    Syntax: pvector &lt;vector&gt; &lt;idx1&gt; &lt;idx2&gt;
    Note: idx, idx1 and idx2 must be in acceptable range [0..&lt;vector&gt;.size()-1].
    Examples:
    pvector v - Prints vector content, size, capacity and T typedef
    pvector v 0 - Prints element[idx] from vector
    pvector v 1 2 - Prints elements in range [idx1..idx2] from vector
end

#
# std::list&lt;&gt;
#

define plist
    if $argc == 0
        help plist
    else
        set $head = &amp;$arg0._M_impl._M_node
        set $current = $arg0._M_impl._M_node._M_next
        set $size = 0
        while $current != $head
            if $argc == 2
                printf &quot;elem[%u]: &quot;, $size
                p *($arg1*)($current + 1)
            end
            if $argc == 3
                if $size == $arg2
                    printf &quot;elem[%u]: &quot;, $size
                    p *($arg1*)($current + 1)
                end
            end
            set $current = $current._M_next
            set $size++
        end
        printf &quot;List size = %u \n&quot;, $size
        if $argc == 1
            printf &quot;List &quot;
            whatis $arg0
            printf &quot;Use plist &lt;variable_name&gt; &lt;element_type&gt; to see the elements in the list.\n&quot;
        end
    end
end

document plist
    Prints std::list&lt;T&gt; information.
    Syntax: plist &lt;list&gt; &lt;T&gt; &lt;idx&gt;: Prints list size, if T defined all elements or just element at idx
    Examples:
    plist l - prints list size and definition
    plist l int - prints all elements and list size
    plist l int 2 - prints the third element in the list (if exists) and list size
end

define plist_member
    if $argc == 0
        help plist_member
    else
        set $head = &amp;$arg0._M_impl._M_node
        set $current = $arg0._M_impl._M_node._M_next
        set $size = 0
        while $current != $head
            if $argc == 3
                printf &quot;elem[%u]: &quot;, $size
                p (*($arg1*)($current + 1)).$arg2
            end
            if $argc == 4
                if $size == $arg3
                    printf &quot;elem[%u]: &quot;, $size
                    p (*($arg1*)($current + 1)).$arg2
                end
            end
            set $current = $current._M_next
            set $size++
        end
        printf &quot;List size = %u \n&quot;, $size
        if $argc == 1
            printf &quot;List &quot;
            whatis $arg0
            printf &quot;Use plist_member &lt;variable_name&gt; &lt;element_type&gt; &lt;member&gt; to see the elements in the list.\n&quot;
        end
    end
end

document plist_member
    Prints std::list&lt;T&gt; information.
    Syntax: plist &lt;list&gt; &lt;T&gt; &lt;idx&gt;: Prints list size, if T defined all elements or just element at idx
    Examples:
    plist_member l int member - prints all elements and list size
    plist_member l int member 2 - prints the third element in the list (if exists) and list size
end


#
# std::map and std::multimap
#

define pmap
    if $argc == 0
        help pmap
    else
        set $tree = $arg0
        set $i = 0
        set $node = $tree._M_t._M_impl._M_header._M_left
        set $end = $tree._M_t._M_impl._M_header
        set $tree_size = $tree._M_t._M_impl._M_node_count
        if $argc == 1
            printf &quot;Map &quot;
            whatis $tree
            printf &quot;Use pmap &lt;variable_name&gt; &lt;left_element_type&gt; &lt;right_element_type&gt; to see the elements in the map.\n&quot;
        end
        if $argc == 3
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                printf &quot;elem[%u].left: &quot;, $i
                p *($arg1*)$value
                set $value = $value + sizeof($arg1)
                printf &quot;elem[%u].right: &quot;, $i
                p *($arg2*)$value
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
        end
        if $argc == 4
            set $idx = $arg3
            set $ElementsFound = 0
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                if *($arg1*)$value == $idx
                    printf &quot;elem[%u].left: &quot;, $i
                    p *($arg1*)$value
                    set $value = $value + sizeof($arg1)
                    printf &quot;elem[%u].right: &quot;, $i
                    p *($arg2*)$value
                    set $ElementsFound++
                end
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
            printf &quot;Number of elements found = %u\n&quot;, $ElementsFound
        end
        if $argc == 5
            set $idx1 = $arg3
            set $idx2 = $arg4
            set $ElementsFound = 0
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                set $valueLeft = *($arg1*)$value
                set $valueRight = *($arg2*)($value + sizeof($arg1))
                if $valueLeft == $idx1 &amp;&amp; $valueRight == $idx2
                    printf &quot;elem[%u].left: &quot;, $i
                    p $valueLeft
                    printf &quot;elem[%u].right: &quot;, $i
                    p $valueRight
                    set $ElementsFound++
                end
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
            printf &quot;Number of elements found = %u\n&quot;, $ElementsFound
        end
        printf &quot;Map size = %u\n&quot;, $tree_size
    end
end

document pmap
    Prints std::map&lt;TLeft and TRight&gt; or std::multimap&lt;TLeft and TRight&gt; information. Works for std::multimap as well.
    Syntax: pmap &lt;map&gt; &lt;TtypeLeft&gt; &lt;TypeRight&gt; &lt;valLeft&gt; &lt;valRight&gt;: Prints map size, if T defined all elements or just element(s) with val(s)
    Examples:
    pmap m - prints map size and definition
    pmap m int int - prints all elements and map size
    pmap m int int 20 - prints the element(s) with left-value = 20 (if any) and map size
    pmap m int int 20 200 - prints the element(s) with left-value = 20 and right-value = 200 (if any) and map size
end


define pmap_member
    if $argc == 0
        help pmap_member
    else
        set $tree = $arg0
        set $i = 0
        set $node = $tree._M_t._M_impl._M_header._M_left
        set $end = $tree._M_t._M_impl._M_header
        set $tree_size = $tree._M_t._M_impl._M_node_count
        if $argc == 1
            printf &quot;Map &quot;
            whatis $tree
            printf &quot;Use pmap &lt;variable_name&gt; &lt;left_element_type&gt; &lt;right_element_type&gt; to see the elements in the map.\n&quot;
        end
        if $argc == 5
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                printf &quot;elem[%u].left: &quot;, $i
                p (*($arg1*)$value).$arg2
                set $value = $value + sizeof($arg1)
                printf &quot;elem[%u].right: &quot;, $i
                p (*($arg3*)$value).$arg4
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
        end
        if $argc == 6
            set $idx = $arg5
            set $ElementsFound = 0
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                if *($arg1*)$value == $idx
                    printf &quot;elem[%u].left: &quot;, $i
                    p (*($arg1*)$value).$arg2
                    set $value = $value + sizeof($arg1)
                    printf &quot;elem[%u].right: &quot;, $i
                    p (*($arg3*)$value).$arg4
                    set $ElementsFound++
                end
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
            printf &quot;Number of elements found = %u\n&quot;, $ElementsFound
        end
        printf &quot;Map size = %u\n&quot;, $tree_size
    end
end

document pmap_member
    Prints std::map&lt;TLeft and TRight&gt; or std::multimap&lt;TLeft and TRight&gt; information. Works for std::multimap as well.
    Syntax: pmap &lt;map&gt; &lt;TtypeLeft&gt; &lt;TypeRight&gt; &lt;valLeft&gt; &lt;valRight&gt;: Prints map size, if T defined all elements or just element(s) with val(s)
    Examples:
    pmap_member m class1 member1 class2 member2 - prints class1.member1 : class2.member2
    pmap_member m class1 member1 class2 member2 lvalue - prints class1.member1 : class2.member2 where class1 == lvalue
end


#
# std::set and std::multiset
#

define pset
    if $argc == 0
        help pset
    else
        set $tree = $arg0
        set $i = 0
        set $node = $tree._M_t._M_impl._M_header._M_left
        set $end = $tree._M_t._M_impl._M_header
        set $tree_size = $tree._M_t._M_impl._M_node_count
        if $argc == 1
            printf &quot;Set &quot;
            whatis $tree
            printf &quot;Use pset &lt;variable_name&gt; &lt;element_type&gt; to see the elements in the set.\n&quot;
        end
        if $argc == 2
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                printf &quot;elem[%u]: &quot;, $i
                p *($arg1*)$value
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
        end
        if $argc == 3
            set $idx = $arg2
            set $ElementsFound = 0
            while $i &lt; $tree_size
                set $value = (void *)($node + 1)
                if *($arg1*)$value == $idx
                    printf &quot;elem[%u]: &quot;, $i
                    p *($arg1*)$value
                    set $ElementsFound++
                end
                if $node._M_right != 0
                    set $node = $node._M_right
                    while $node._M_left != 0
                        set $node = $node._M_left
                    end
                else
                    set $tmp_node = $node._M_parent
                    while $node == $tmp_node._M_right
                        set $node = $tmp_node
                        set $tmp_node = $tmp_node._M_parent
                    end
                    if $node._M_right != $tmp_node
                        set $node = $tmp_node
                    end
                end
                set $i++
            end
            printf &quot;Number of elements found = %u\n&quot;, $ElementsFound
        end
        printf &quot;Set size = %u\n&quot;, $tree_size
    end
end

document pset
    Prints std::set&lt;T&gt; or std::multiset&lt;T&gt; information. Works for std::multiset as well.
    Syntax: pset &lt;set&gt; &lt;T&gt; &lt;val&gt;: Prints set size, if T defined all elements or just element(s) having val
    Examples:
    pset s - prints set size and definition
    pset s int - prints all elements and the size of s
    pset s int 20 - prints the element(s) with value = 20 (if any) and the size of s
end



#
# std::dequeue
#

define pdequeue
    if $argc == 0
        help pdequeue
    else
        set $size = 0
        set $start_cur = $arg0._M_impl._M_start._M_cur
        set $start_last = $arg0._M_impl._M_start._M_last
        set $start_stop = $start_last
        while $start_cur != $start_stop
            p *$start_cur
            set $start_cur++
            set $size++
        end
        set $finish_first = $arg0._M_impl._M_finish._M_first
        set $finish_cur = $arg0._M_impl._M_finish._M_cur
        set $finish_last = $arg0._M_impl._M_finish._M_last
        if $finish_cur &lt; $finish_last
            set $finish_stop = $finish_cur
        else
            set $finish_stop = $finish_last
        end
        while $finish_first != $finish_stop
            p *$finish_first
            set $finish_first++
            set $size++
        end
        printf &quot;Dequeue size = %u\n&quot;, $size
    end
end

document pdequeue
    Prints std::dequeue&lt;T&gt; information.
    Syntax: pdequeue &lt;dequeue&gt;: Prints dequeue size, if T defined all elements
    Deque elements are listed &quot;left to right&quot; (left-most stands for front and right-most stands for back)
    Example:
    pdequeue d - prints all elements and size of d
end



#
# std::stack
#

define pstack
    if $argc == 0
        help pstack
    else
        set $start_cur = $arg0.c._M_impl._M_start._M_cur
        set $finish_cur = $arg0.c._M_impl._M_finish._M_cur
        set $size = $finish_cur - $start_cur
        set $i = $size - 1
        while $i &gt;= 0
            p *($start_cur + $i)
            set $i--
        end
        printf &quot;Stack size = %u\n&quot;, $size
    end
end

document pstack
    Prints std::stack&lt;T&gt; information.
    Syntax: pstack &lt;stack&gt;: Prints all elements and size of the stack
    Stack elements are listed &quot;top to buttom&quot; (top-most element is the first to come on pop)
    Example:
    pstack s - prints all elements and the size of s
end



#
# std::queue
#

define pqueue
    if $argc == 0
        help pqueue
    else
        set $start_cur = $arg0.c._M_impl._M_start._M_cur
        set $finish_cur = $arg0.c._M_impl._M_finish._M_cur
        set $size = $finish_cur - $start_cur
        set $i = 0
        while $i &lt; $size
            p *($start_cur + $i)
            set $i++
        end
        printf &quot;Queue size = %u\n&quot;, $size
    end
end

document pqueue
    Prints std::queue&lt;T&gt; information.
    Syntax: pqueue &lt;queue&gt;: Prints all elements and the size of the queue
    Queue elements are listed &quot;top to bottom&quot; (top-most element is the first to come on pop)
    Example:
    pqueue q - prints all elements and the size of q
end



#
# std::priority_queue
#

define ppqueue
    if $argc == 0
        help ppqueue
    else
        set $size = $arg0.c._M_impl._M_finish - $arg0.c._M_impl._M_start
        set $capacity = $arg0.c._M_impl._M_end_of_storage - $arg0.c._M_impl._M_start
        set $i = $size - 1
        while $i &gt;= 0
            p *($arg0.c._M_impl._M_start + $i)
            set $i--
        end
        printf &quot;Priority queue size = %u\n&quot;, $size
        printf &quot;Priority queue capacity = %u\n&quot;, $capacity
    end
end

document ppqueue
    Prints std::priority_queue&lt;T&gt; information.
    Syntax: ppqueue &lt;priority_queue&gt;: Prints all elements, size and capacity of the priority_queue
    Priority_queue elements are listed &quot;top to buttom&quot; (top-most element is the first to come on pop)
    Example:
    ppqueue pq - prints all elements, size and capacity of pq
end



#
# std::bitset
#

define pbitset
    if $argc == 0
        help pbitset
    else
        p /t $arg0._M_w
    end
end

document pbitset
    Prints std::bitset&lt;n&gt; information.
    Syntax: pbitset &lt;bitset&gt;: Prints all bits in bitset
    Example:
    pbitset b - prints all bits in b
end



#
# std::string
#

define pstring
    if $argc == 0
        help pstring
    else
        printf &quot;String \t\t\t= \&quot;%s\&quot;\n&quot;, $arg0._M_data()
        printf &quot;String size/length \t= %u\n&quot;, $arg0._M_rep()._M_length
        printf &quot;String capacity \t= %u\n&quot;, $arg0._M_rep()._M_capacity
        printf &quot;String ref-count \t= %d\n&quot;, $arg0._M_rep()._M_refcount
    end
end

document pstring
    Prints std::string information.
    Syntax: pstring &lt;string&gt;
    Example:
    pstring s - Prints content, size/length, capacity and ref-count of string s
end

#
# std::wstring
#

define pwstring
    if $argc == 0
        help pwstring
    else
        call printf(&quot;WString \t\t= \&quot;%ls\&quot;\n&quot;, $arg0._M_data())
        printf &quot;WString size/length \t= %u\n&quot;, $arg0._M_rep()._M_length
        printf &quot;WString capacity \t= %u\n&quot;, $arg0._M_rep()._M_capacity
        printf &quot;WString ref-count \t= %d\n&quot;, $arg0._M_rep()._M_refcount
    end
end

document pwstring
    Prints std::wstring information.
    Syntax: pwstring &lt;wstring&gt;
    Example:
    pwstring s - Prints content, size/length, capacity and ref-count of wstring s
end

#
# C++ related beautifiers (optional)
#

set print pretty on
set print object on
set print static-members on
set print vtbl on
set print demangle on
set demangle-style gnu-v3
set print sevenbit-strings off

set follow-fork-mode child
set detach-on-fork off
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gdb-navigate-in-threads.html" class="btn btn-neutral float-right" title="gdb: navigate in threads" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="gdb-commands.html" class="btn btn-neutral float-left" title="gdb commands" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Geoffrey Papaux

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>